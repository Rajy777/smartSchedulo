from config import (
    SIMULATION_START_HOUR,
    SIMULATION_END_HOUR,
    TIME_STEP_MINUTES,
    IDEAL_TEMP,
    COOLING_COEFFICIENT,
    HEAT_ACCUMULATION,
    COOLING_EFFICIENCY,
    THERMAL_DISSIPATION,
)
from metrics import Metrics


# Ambient temperature model
def ambient_temperature(hour):
    if 6 <= hour <= 18:
        return 30 + 5 * ((hour - 12) ** 2) / 36
    else:
        return 25


# Solar generation model (kW)
def solar_power(hour):
    if 6 <= hour <= 18:
        return max(0, 5 * (1 - abs(hour - 12) / 6))
    else:
        return 0


# Cooling power demand (kW)
def cooling_power_kw(temp):
    if temp <= IDEAL_TEMP:
        return 0
    return (temp - IDEAL_TEMP) * COOLING_COEFFICIENT


def run_simulation(scheduler, smart=True):
    metrics = Metrics()

    time_log = []
    grid_log = []
    solar_log = []
    cooling_log = []
    temp_log = []

    current_temp = ambient_temperature(SIMULATION_START_HOUR)
    current_hour = SIMULATION_START_HOUR

    while current_hour < SIMULATION_END_HOUR:
        ambient = ambient_temperature(current_hour)
        solar = solar_power(current_hour) if smart else 0

        # Scheduler interface
        if smart:
            running_jobs = scheduler.schedule(solar, current_temp, current_hour)
        else:
            running_jobs = scheduler.schedule(0, current_temp)

        # Heat generated by running jobs
        job_heat = sum(job.power_kw for job in running_jobs)

        # Cooling applied
        cooling = cooling_power_kw(current_temp)

        # Thermal inertia update
        current_temp = (
            current_temp
            + HEAT_ACCUMULATION * job_heat
            - COOLING_EFFICIENCY * cooling
            - THERMAL_DISSIPATION * (current_temp - ambient)
        )

        # Electrical power draw
        grid_power = job_heat

        # Metrics
        dt_hours = TIME_STEP_MINUTES / 60
        metrics.add_energy(grid_power, solar, dt_hours)
        metrics.add_cooling(cooling, dt_hours)

        # Advance jobs
        for job in running_jobs:
            job.run_step(TIME_STEP_MINUTES)

        # âœ… SLA penalty check
        for job in scheduler.jobs:
            if job.deadline_missed(current_hour):
                metrics.add_deadline_penalty()
                job.penalized = True

        # Logs
        time_log.append(current_hour)
        grid_log.append(grid_power)
        solar_log.append(solar)
        cooling_log.append(cooling)
        temp_log.append(current_temp)

        current_hour += TIME_STEP_MINUTES / 60

    return metrics, time_log, grid_log, solar_log, cooling_log, temp_log
